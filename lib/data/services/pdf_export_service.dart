import 'dart:io';
import 'dart:typed_data';
import 'package:pdf/pdf.dart';
import 'package:pdf/widgets.dart' as pw;
import 'package:printing/printing.dart';
import '../models/song.dart';
import '../models/section.dart';
import '../models/structure.dart';
import '../models/measure.dart';
import '../../core/constants/app_constants.dart';
import '../../core/constants/music_constants.dart';
import '../../core/utils/chord_parser.dart';

/// Service for exporting chord grids to PDF format
class PdfExportService {
  /// Export a single song to PDF
  static Future<Uint8List> exportSongToPdf(Song song) async {
    final pdf = pw.Document();

    // Add title page
    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (pw.Context context) {
          return _buildTitlePage(song);
        },
      ),
    );

    // Add chord grid pages
    final chordGridPages = _buildChordGridPages(song);
    for (final page in chordGridPages) {
      pdf.addPage(page);
    }

    return await pdf.save();
  }

  /// Export multiple songs to PDF
  static Future<Uint8List> exportSongsToPdf(List<Song> songs) async {
    final pdf = pw.Document();

    // Add table of contents
    pdf.addPage(
      pw.Page(
        pageFormat: PdfPageFormat.a4,
        build: (pw.Context context) {
          return _buildTableOfContents(songs);
        },
      ),
    );

    // Add each song
    for (final song in songs) {
      // Add title page for song
      pdf.addPage(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return _buildTitlePage(song);
          },
        ),
      );

      // Add chord grid pages for song
      final chordGridPages = _buildChordGridPages(song);
      for (final page in chordGridPages) {
        pdf.addPage(page);
      }
    }

    return await pdf.save();
  }

  /// Build title page for a song
  static pw.Widget _buildTitlePage(Song song) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Header(
          level: 0,
          child: pw.Text(
            song.title,
            style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
          ),
        ),
        pw.SizedBox(height: 10),
        pw.Text(
          'by ${song.artist}',
          style: pw.TextStyle(fontSize: 18, fontStyle: pw.FontStyle.italic),
        ),
        pw.SizedBox(height: 20),
        pw.Container(
          padding: const pw.EdgeInsets.all(16),
          decoration: pw.BoxDecoration(
            border: pw.Border.all(color: PdfColors.grey),
            borderRadius: pw.BorderRadius.circular(8),
          ),
          child: pw.Column(
            crossAxisAlignment: pw.CrossAxisAlignment.start,
            children: [
              pw.Text(
                'Song Information',
                style: pw.TextStyle(
                  fontSize: 16,
                  fontWeight: pw.FontWeight.bold,
                ),
              ),
              pw.SizedBox(height: 10),
              _buildInfoRow('Key', song.key),
              _buildInfoRow('Time Signature', song.timeSignature),
              if (song.tempo != null)
                _buildInfoRow('Tempo', '${song.tempo} BPM'),
              if (song.style != null && song.style!.isNotEmpty)
                _buildInfoRow('Style', song.style!),
              _buildInfoRow('Notation', song.notationType),
              _buildInfoRow('Created', _formatDate(song.createdAt)),
              _buildInfoRow('Updated', _formatDate(song.updatedAt)),
            ],
          ),
        ),
        pw.Spacer(),
        pw.Center(
          child: pw.Text(
            'Generated by ${AppConstants.appName}',
            style: pw.TextStyle(fontSize: 10, color: PdfColors.grey),
          ),
        ),
      ],
    );
  }

  /// Build table of contents
  static pw.Widget _buildTableOfContents(List<Song> songs) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Header(
          level: 0,
          child: pw.Text(
            'Table of Contents',
            style: pw.TextStyle(fontSize: 24, fontWeight: pw.FontWeight.bold),
          ),
        ),
        pw.SizedBox(height: 20),
        for (int i = 0; i < songs.length; i++)
          pw.Container(
            margin: const pw.EdgeInsets.only(bottom: 8),
            child: pw.Row(
              children: [
                pw.Text('${i + 1}.', style: pw.TextStyle(fontSize: 12)),
                pw.SizedBox(width: 10),
                pw.Expanded(
                  child: pw.Text(
                    '${songs[i].title} - ${songs[i].artist}',
                    style: pw.TextStyle(fontSize: 12),
                  ),
                ),
                pw.Text('Page ${i * 2 + 2}', style: pw.TextStyle(fontSize: 12)),
              ],
            ),
          ),
      ],
    );
  }

  /// Build chord grid pages for a song
  static List<pw.Page> _buildChordGridPages(Song song) {
    final pages = <pw.Page>[];
    final measuresPerPage = 16; // Adjust based on page size and font

    // Calculate total measures
    final totalMeasures = song.totalMeasures;
    final totalPages = (totalMeasures / measuresPerPage).ceil();

    for (int pageIndex = 0; pageIndex < totalPages; pageIndex++) {
      final startMeasure = pageIndex * measuresPerPage;
      final endMeasure = (startMeasure + measuresPerPage).clamp(
        0,
        totalMeasures,
      );

      pages.add(
        pw.Page(
          pageFormat: PdfPageFormat.a4,
          build: (pw.Context context) {
            return _buildChordGridPage(
              song,
              startMeasure,
              endMeasure,
              pageIndex + 1,
              totalPages,
            );
          },
        ),
      );
    }

    return pages;
  }

  /// Build a single chord grid page
  static pw.Widget _buildChordGridPage(
    Song song,
    int startMeasure,
    int endMeasure,
    int pageNumber,
    int totalPages,
  ) {
    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: [
        pw.Row(
          mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
          children: [
            pw.Text(
              '${song.title} - ${song.artist}',
              style: pw.TextStyle(fontSize: 14, fontWeight: pw.FontWeight.bold),
            ),
            pw.Text(
              'Page $pageNumber of $totalPages',
              style: pw.TextStyle(fontSize: 10, color: PdfColors.grey),
            ),
          ],
        ),
        pw.SizedBox(height: 10),
        pw.Container(
          padding: const pw.EdgeInsets.all(8),
          decoration: pw.BoxDecoration(
            border: pw.Border.all(color: PdfColors.grey),
          ),
          child: _buildChordGrid(song, startMeasure, endMeasure),
        ),
        pw.SizedBox(height: 10),
        _buildPageFooter(song),
      ],
    );
  }

  /// Build the actual chord grid
  static pw.Widget _buildChordGrid(
    Song song,
    int startMeasure,
    int endMeasure,
  ) {
    final rows = <pw.Widget>[];
    int currentMeasure = 0;

    for (final section in song.sections) {
      for (int repeat = 0; repeat < section.repeatCount; repeat++) {
        // Add section header if it's the first repeat
        if (repeat == 0) {
          rows.add(
            pw.Container(
              padding: const pw.EdgeInsets.all(4),
              color: PdfColors.grey200,
              child: pw.Text(
                section.displayName,
                style: pw.TextStyle(
                  fontSize: 12,
                  fontWeight: pw.FontWeight.bold,
                ),
              ),
            ),
          );
        }

        // Add measures for this section repeat
        final measures = <pw.Widget>[];
        for (int i = 0; i < section.measures.length; i++) {
          if (currentMeasure >= startMeasure && currentMeasure < endMeasure) {
            final measure = section.measures[i];
            final chordText = measure.displayText;
            measures.add(
              pw.Container(
                width: 60,
                height: 40,
                decoration: pw.BoxDecoration(
                  border: pw.Border.all(color: PdfColors.grey),
                ),
                child: pw.Center(
                  child: pw.Text(
                    chordText,
                    style: pw.TextStyle(
                      fontSize: 10,
                      fontWeight: chordText.isNotEmpty && chordText != '|'
                          ? pw.FontWeight.bold
                          : pw.FontWeight.normal,
                    ),
                  ),
                ),
              ),
            );
          }
          currentMeasure++;
        }

        if (measures.isNotEmpty) {
          rows.add(pw.Wrap(spacing: 2, runSpacing: 2, children: measures));
        }
      }
    }

    return pw.Column(
      crossAxisAlignment: pw.CrossAxisAlignment.start,
      children: rows,
    );
  }

  /// Build page footer
  static pw.Widget _buildPageFooter(Song song) {
    return pw.Row(
      mainAxisAlignment: pw.MainAxisAlignment.spaceBetween,
      children: [
        pw.Text(
          'Key: ${song.key} | Time: ${song.timeSignature} | ${song.tempo != null ? 'Tempo: ${song.tempo} BPM' : ''}',
          style: pw.TextStyle(fontSize: 8),
        ),
        pw.Text(
          '${AppConstants.appName} - ${DateTime.now().year}',
          style: pw.TextStyle(fontSize: 8, color: PdfColors.grey),
        ),
      ],
    );
  }

  /// Build info row for title page
  static pw.Widget _buildInfoRow(String label, String value) {
    return pw.Container(
      margin: const pw.EdgeInsets.only(bottom: 4),
      child: pw.Row(
        children: [
          pw.Text(
            '$label:',
            style: pw.TextStyle(fontSize: 12, fontWeight: pw.FontWeight.bold),
          ),
          pw.SizedBox(width: 10),
          pw.Text(value, style: pw.TextStyle(fontSize: 12)),
        ],
      ),
    );
  }

  /// Format date for display
  static String _formatDate(DateTime date) {
    return '${date.day}/${date.month}/${date.year}';
  }

  /// Preview PDF in printing dialog
  static Future<void> previewPdf(Uint8List pdfBytes) async {
    await Printing.layoutPdf(
      onLayout: (PdfPageFormat format) async => pdfBytes,
    );
  }

  /// Share PDF file
  static Future<void> sharePdf(Uint8List pdfBytes, String fileName) async {
    // This would typically use the share_plus package
    // For now, we'll just save the file
    await _savePdfFile(pdfBytes, fileName);
  }

  /// Save PDF to device storage
  static Future<void> _savePdfFile(Uint8List pdfBytes, String fileName) async {
    // Implementation would use path_provider and file operations
    // This is a placeholder for the actual file saving logic
    print('Saving PDF file: $fileName');
  }

  /// Get PDF file size
  static String getPdfFileSize(Uint8List pdfBytes) {
    return AppConstants.formatFileSize(pdfBytes.length);
  }

  /// Validate PDF export settings
  static List<String> validateExportSettings(Map<String, dynamic> settings) {
    final errors = <String>[];

    final fileName = settings['fileName'] as String?;
    if (fileName == null || fileName.isEmpty) {
      errors.add('File name is required');
    } else if (!AppConstants.isValidFileName(fileName)) {
      errors.add('Invalid file name');
    }

    final quality = settings['quality'] as int?;
    if (quality != null && (quality < 1 || quality > 100)) {
      errors.add('Quality must be between 1 and 100');
    }

    return errors;
  }

  /// Export song as PDF file (updated method for ExportProvider)
  static Future<File?> exportSongAsPDF(
    Song song, {
    String pageSize = 'A4',
    String orientation = 'PORTRAIT',
    bool includeMetadata = true,
    bool showMusicSymbols = true,
    double fontSize = 12.0,
  }) async {
    try {
      final pdfBytes = await exportSongToPdf(song);
      // In a real implementation, this would save to a file and return File object
      // For now, return null as placeholder
      return null;
    } catch (e) {
      print('Error exporting song as PDF: $e');
      return null;
    }
  }
}
